
package com.filegenerator.ui;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.dialogs.TitleAreaDialog;
import org.eclipse.jface.viewers.ArrayContentProvider;
import org.eclipse.jface.viewers.CheckStateChangedEvent;
import org.eclipse.jface.viewers.CheckboxTableViewer;
import org.eclipse.jface.viewers.ICheckStateListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.SashForm;
import org.eclipse.swt.dnd.Clipboard;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.swt.widgets.Text;

import com.filegenerator.core.BackupManager;
import com.filegenerator.core.patch.PatchApplier;
import com.filegenerator.core.patch.PatchApplier.ApplyContentResult;
import com.filegenerator.core.patch.PatchFile;
import com.filegenerator.core.patch.PatchFileType;
import com.filegenerator.core.patch.PatchParseResult;
import com.filegenerator.core.patch.PatchParser;

public class PatchInputDialog extends TitleAreaDialog {

    private final IProject project;

    private Text patchText;
    private CheckboxTableViewer fileTable;
    private Text originalPreview;
    private Text newPreview;
    private Button backupCheckbox;
    private Label statusLabel;

    private PatchParseResult parseResult;
    private List<PatchFile> applicableFiles = new ArrayList<>();
    private PatchFile selectedPatchFile;

    private BackupManager backupManager;

    public PatchInputDialog(Shell parentShell, IProject project) {
        super(parentShell);
        this.project = project;
        this.backupManager = new BackupManager();
    }

    @Override
    public void create() {
        super.create();
        setTitle("Apply LLM Patch");
        setMessage("Paste the unified diff / patch generated by LLM, review changes, then apply.");
    }

    @Override
    protected Control createDialogArea(Composite parent) {
        Composite container = (Composite) super.createDialogArea(parent);

        SashForm sashForm = new SashForm(container, SWT.VERTICAL);
        sashForm.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

        createTopArea(sashForm);
        createBottomArea(sashForm);

        sashForm.setWeights(new int[] { 3, 3 });

        return container;
    }

    private void createTopArea(Composite parent) {
        Composite top = new Composite(parent, SWT.NONE);
        top.setLayout(new GridLayout(2, false));

        Label label = new Label(top, SWT.NONE);
        label.setText("Patch text:");
        GridData ld = new GridData();
        ld.horizontalSpan = 2;
        label.setLayoutData(ld);

        patchText = new Text(top, SWT.BORDER | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL);
        GridData gd = new GridData(SWT.FILL, SWT.FILL, true, true);
        gd.horizontalSpan = 2;
        patchText.setLayoutData(gd);

        Composite buttonBar = new Composite(top, SWT.NONE);
        buttonBar.setLayout(new GridLayout(3, false));
        GridData bbGd = new GridData(SWT.FILL, SWT.CENTER, true, false);
        bbGd.horizontalSpan = 2;
        buttonBar.setLayoutData(bbGd);

        Button pasteButton = new Button(buttonBar, SWT.PUSH);
        pasteButton.setText("Paste from Clipboard");
        pasteButton.addListener(SWT.Selection, e -> {
            Clipboard clipboard = new Clipboard(getShell().getDisplay());
            String data = (String) clipboard.getContents(org.eclipse.swt.dnd.TextTransfer.getInstance());
            clipboard.dispose();
            if (data != null) {
                patchText.setText(data);
            }
        });

        Button clearButton = new Button(buttonBar, SWT.PUSH);
        clearButton.setText("Clear");
        clearButton.addListener(SWT.Selection, e -> {
            patchText.setText("");
            clearParseResult();
        });

        Button parseButton = new Button(buttonBar, SWT.PUSH);
        parseButton.setText("Parse Patch");
        parseButton.addListener(SWT.Selection, e -> parsePatch());

        backupCheckbox = new Button(top, SWT.CHECK);
        backupCheckbox.setText("Backup all affected files before applying patch (recommended)");
        backupCheckbox.setSelection(true);
        GridData backupGd = new GridData(SWT.LEFT, SWT.CENTER, true, false);
        backupGd.horizontalSpan = 2;
        backupCheckbox.setLayoutData(backupGd);

        statusLabel = new Label(top, SWT.NONE);
        GridData statusGd = new GridData(SWT.FILL, SWT.CENTER, true, false);
        statusGd.horizontalSpan = 2;
        statusLabel.setLayoutData(statusGd);
    }

    private void createBottomArea(Composite parent) {
        SashForm bottomSash = new SashForm(parent, SWT.HORIZONTAL);
        bottomSash.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

        // 左侧：文件列表
        Composite left = new Composite(bottomSash, SWT.NONE);
        left.setLayout(new GridLayout(1, false));

        Label fileLabel = new Label(left, SWT.NONE);
        fileLabel.setText("Files in patch:");

        fileTable = CheckboxTableViewer.newCheckList(left, SWT.BORDER | SWT.FULL_SELECTION | SWT.V_SCROLL);
        Table table = fileTable.getTable();
        table.setHeaderVisible(true);
        table.setLinesVisible(true);
        table.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

        TableColumn colPath = new TableColumn(table, SWT.LEFT);
        colPath.setText("Path");
        colPath.setWidth(280);

        TableColumn colType = new TableColumn(table, SWT.LEFT);
        colType.setText("Type");
        colType.setWidth(80);

        TableColumn colStatus = new TableColumn(table, SWT.LEFT);
        colStatus.setText("Status");
        colStatus.setWidth(160);

        fileTable.setContentProvider(ArrayContentProvider.getInstance());
        fileTable.setLabelProvider(new LabelProvider() {
            @Override
            public String getText(Object element) {
                return super.getText(element);
            }
        });

        fileTable.setCheckStateProvider(new org.eclipse.jface.viewers.ICheckStateProvider() {
            @Override
            public boolean isChecked(Object element) {
                return applicableFiles.contains(element);
            }

            @Override
            public boolean isGrayed(Object element) {
                return false;
            }
        });

        fileTable.addCheckStateListener(new ICheckStateListener() {
            @Override
            public void checkStateChanged(CheckStateChangedEvent event) {
                Object element = event.getElement();
                if (!(element instanceof PatchFile)) {
                    return;
                }
                PatchFile pf = (PatchFile) element;
                if (event.getChecked()) {
                    if (!applicableFiles.contains(pf)) {
                        applicableFiles.add(pf);
                    }
                } else {
                    applicableFiles.remove(pf);
                }
                updateStatus();
            }
        });

        fileTable.addSelectionChangedListener(event -> {
            IStructuredSelection sel = (IStructuredSelection) event.getSelection();
            Object elem = sel.getFirstElement();
            if (elem instanceof PatchFile) {
                selectedPatchFile = (PatchFile) elem;
                updatePreview();
            } else {
                selectedPatchFile = null;
                clearPreview();
            }
        });

        // 右侧：原文/新文预览
        Composite right = new Composite(bottomSash, SWT.NONE);
        right.setLayout(new GridLayout(2, true));

        Label origLabel = new Label(right, SWT.NONE);
        origLabel.setText("Original Content:");
        origLabel.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));

        Label newLabel = new Label(right, SWT.NONE);
        newLabel.setText("New Content:");
        newLabel.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));

        originalPreview = new Text(right, SWT.BORDER | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL | SWT.READ_ONLY);
        originalPreview.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

        newPreview = new Text(right, SWT.BORDER | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL | SWT.READ_ONLY);
        newPreview.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

        bottomSash.setWeights(new int[] { 2, 3 });
    }

    private void parsePatch() {
        clearParseResult();

        String patch = patchText.getText();
        if (patch == null || patch.trim().isEmpty()) {
            setErrorMessage("Patch text is empty.");
            return;
        }

        PatchParser parser = new PatchParser();
        parseResult = parser.parse(patch);

        if (parseResult.hasErrors()) {
            setErrorMessage("Errors in patch:\n" + String.join("\n", parseResult.getErrors()));
        } else {
            setErrorMessage(null);
        }

        List<PatchFile> files = parseResult.getFiles();
        fileTable.setInput(files);
        // 默认全部勾选（仅对可应用的，后面校验）
        applicableFiles.clear();
        for (PatchFile pf : files) {
            // 简单检查：路径合法
            String relPath = normalizeEffectivePath(pf);
            if (relPath == null) {
                continue;
            }
            applicableFiles.add(pf);
        }
        fileTable.setAllChecked(true);
        updateStatus();
    }

    private void clearParseResult() {
        parseResult = null;
        applicableFiles.clear();
        fileTable.setInput(new Object[0]);
        clearPreview();
        statusLabel.setText("");
        setErrorMessage(null);
    }

    private void updateStatus() {
        if (parseResult == null) {
            statusLabel.setText("");
            return;
        }
        int total = parseResult.getFiles().size();
        int checked = applicableFiles.size();
        statusLabel.setText("Parsed files: " + total + ", selected: " + checked);
        updateButtonsEnablement();
    }

    private void updateButtonsEnablement() {
        Button ok = getButton(IDialogConstants.OK_ID);
        if (ok != null) {
            boolean enabled = parseResult != null && !applicableFiles.isEmpty();
            ok.setEnabled(enabled);
        }
    }

    private void updatePreview() {
        if (selectedPatchFile == null) {
            clearPreview();
            return;
        }
        String relPath = normalizeEffectivePath(selectedPatchFile);
        if (relPath == null) {
            clearPreview();
            return;
        }
        IFile file = project.getFile(relPath);
        PatchApplier applier = new PatchApplier();

        try {
            if (selectedPatchFile.getType() == PatchFileType.ADD) {
                originalPreview.setText("(File does not exist. This patch will create it.)");
                String newContent = applier.buildContentForAdd(selectedPatchFile);
                newPreview.setText(newContent);
            } else if (selectedPatchFile.getType() == PatchFileType.DELETE) {
                if (file.exists()) {
                    String original = readFileContent(file);
                    originalPreview.setText(original);
                } else {
                    originalPreview.setText("(File does not exist in project.)");
                }
                newPreview.setText("(File will be deleted.)");
            } else {
                if (file.exists()) {
                    String original = readFileContent(file);
                    originalPreview.setText(original);
                    ApplyContentResult result = applier.applyToExistingContent(original, selectedPatchFile);
                    if (result.isSuccess()) {
                        newPreview.setText(result.getNewContent());
                    } else {
                        newPreview.setText("Failed to apply patch in preview: " + result.getError());
                    }
                } else {
                    originalPreview.setText("(File does not exist in project.)");
                    newPreview.setText("Cannot preview MODIFY patch: file not found.");
                }
            }
        } catch (CoreException e) {
            originalPreview.setText("Error reading file: " + e.getMessage());
            newPreview.setText("");
        }
    }

    private void clearPreview() {
        originalPreview.setText("");
        newPreview.setText("");
    }

    private String normalizeEffectivePath(PatchFile pf) {
        String p = pf.getEffectivePath();
        if (p == null) {
            return null;
        }
        if ("/dev/null".equals(p)) {
            return null;
        }
        while (p.startsWith("/")) {
            p = p.substring(1);
        }
        return p;
    }

    private String readFileContent(IFile file) throws CoreException {
        try {
            byte[] bytes = file.getContents().readAllBytes();
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new CoreException(org.eclipse.core.runtime.Status.error("Error reading file: " + e.getMessage(), e));
        }
    }

    public List<PatchFile> getSelectedPatchFiles() {
        return new ArrayList<>(applicableFiles);
    }

    public BackupManager getBackupManager() {
        return backupManager;
    }

    public boolean isBackupEnabled() {
        return backupCheckbox.getSelection();
    }

    @Override
    protected void createButtonsForButtonBar(Composite parent) {
        super.createButtonsForButtonBar(parent);
        Button okButton = getButton(IDialogConstants.OK_ID);
        okButton.setText("Apply Patch");
        okButton.setEnabled(false);
    }

    @Override
    protected void okPressed() {
        // 在这里不做实际应用，只是关闭对话框，由 handler 处理。
        super.okPressed();
    }

    @Override
    protected boolean isResizable() {
        return true;
    }
}


// ============================================================================
